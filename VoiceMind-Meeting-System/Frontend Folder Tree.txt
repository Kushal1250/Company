Frontend Folder Tree

voicemind-frontend/
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ favicon.ico
‚îÇ   ‚îî‚îÄ‚îÄ manifest.json
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ assets/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logo.png
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ styles/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ global.css
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ variables.css
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Header.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Sidebar.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoadingSpinner.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ErrorBoundary.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Toast.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ meeting/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MeetingList.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MeetingCard.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MeetingDetail.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RecordingControls.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StatusIndicator.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ transcript/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TranscriptViewer.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TranscriptSegment.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SearchTranscript.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ qa/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChatInterface.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ QuestionInput.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AnswerCard.jsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ summary/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ SummaryView.jsx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ AgendaView.jsx
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ActionItemsList.jsx
‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MeetingPage.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AnalyticsPage.jsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SettingsPage.jsx
‚îÇ   ‚îú‚îÄ‚îÄ redux/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ slices/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ meetingSlice.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ transcriptSlice.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ qaSlice.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ uiSlice.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ websocketMiddleware.js
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ meetingService.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ transcriptionService.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ qaService.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ websocketService.js
‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useMeetings.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useWebSocket.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useAudio.js
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dateFormatter.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ audioUtils.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validators.js
‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îú‚îÄ‚îÄ App.css
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îî‚îÄ‚îÄ index.css
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ vite.config.js (or webpack.config.js)














VS Code Setup Commands

# Navigate to your project root
cd ~/Projects

# Create frontend directory
mkdir voicemind-frontend
cd voicemind-frontend

# Create all directories
mkdir -p public src/assets/images src/assets/styles src/components/common src/components/meeting src/components/transcript src/components/qa src/components/summary src/pages src/redux/slices src/redux/middleware src/services src/hooks src/utils

# Create public files
touch public/index.html public/favicon.ico public/manifest.json

# Create asset files
touch src/assets/styles/global.css src/assets/styles/variables.css

# Create common components
touch src/components/common/Header.jsx src/components/common/Sidebar.jsx src/components/common/LoadingSpinner.jsx src/components/common/ErrorBoundary.jsx src/components/common/Toast.jsx

# Create meeting components
touch src/components/meeting/MeetingList.jsx src/components/meeting/MeetingCard.jsx src/components/meeting/MeetingDetail.jsx src/components/meeting/RecordingControls.jsx src/components/meeting/StatusIndicator.jsx

# Create transcript components
touch src/components/transcript/TranscriptViewer.jsx src/components/transcript/TranscriptSegment.jsx src/components/transcript/SearchTranscript.jsx

# Create QA components
touch src/components/qa/ChatInterface.jsx src/components/qa/QuestionInput.jsx src/components/qa/AnswerCard.jsx

# Create summary components
touch src/components/summary/SummaryView.jsx src/components/summary/AgendaView.jsx src/components/summary/ActionItemsList.jsx

# Create pages
touch src/pages/Dashboard.jsx src/pages/MeetingPage.jsx src/pages/AnalyticsPage.jsx src/pages/SettingsPage.jsx

# Create Redux files
touch src/redux/store.js src/redux/slices/meetingSlice.js src/redux/slices/transcriptSlice.js src/redux/slices/qaSlice.js src/redux/slices/uiSlice.js src/redux/middleware/websocketMiddleware.js

# Create services
touch src/services/api.js src/services/meetingService.js src/services/transcriptionService.js src/services/qaService.js src/services/websocketService.js

# Create hooks
touch src/hooks/useMeetings.js src/hooks/useWebSocket.js src/hooks/useAudio.js

# Create utils
touch src/utils/dateFormatter.js src/utils/audioUtils.js src/utils/validators.js

# Create root files
touch src/App.jsx src/App.css src/index.js src/index.css .env .env.example .gitignore package.json README.md vite.config.js

# Open in VS Code
code .




Installation Commands


{
  "name": "voicemind-frontend",
  "version": "1.0.0",
  "description": "VoiceMind Meeting Intelligence System - MERN Frontend",
  "main": "src/index.js",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext js,jsx",
    "format": "prettier --write \"src/**/*.{js,jsx,css}\"",
    "test": "jest"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "@reduxjs/toolkit": "^2.0.1",
    "react-redux": "^9.0.4",
    "axios": "^1.6.2",
    "socket.io-client": "^4.5.4",
    "@mui/material": "^5.15.0",
    "@mui/icons-material": "^5.15.0",
    "@emotion/react": "^11.11.1",
    "@emotion/styled": "^11.11.0",
    "recharts": "^2.10.3",
    "react-wavesurfer": "^2.0.0",
    "wavesurfer.js": "^7.4.4",
    "date-fns": "^3.0.6",
    "react-toastify": "^9.1.3",
    "framer-motion": "^10.16.16",
    "react-markdown": "^9.0.1"
  },
  "devDependencies": {
    "vite": "^5.0.7",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.55.0",
    "eslint-plugin-react": "^7.33.2",
    "prettier": "^3.1.1",
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17"
  }
}







Installation Commands

# Initialize Node project (if package.json not created yet)
npm init -y

# Install all dependencies
npm install

# Or with Yarn
yarn install



.env.example

# Backend API Configuration
VITE_API_BASE_URL=http://localhost:8000
VITE_WS_BASE_URL=ws://localhost:8000

# Feature Flags
VITE_ENABLE_WEBSOCKET=true
VITE_ENABLE_ANALYTICS=true

# API Timeout (milliseconds)
VITE_API_TIMEOUT=30000

# Audio Configuration
VITE_AUDIO_SAMPLE_RATE=16000
VITE_AUDIO_CHUNK_SIZE=32000
VITE_AUDIO_FORMAT=wav

# UI Configuration
VITE_THEME=light
VITE_ITEMS_PER_PAGE=10





.env (Create from example)
cp .env.example .env
# Edit .env with your actual values



vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@components': path.resolve(__dirname, './src/components'),
      '@pages': path.resolve(__dirname, './src/pages'),
      '@services': path.resolve(__dirname, './src/services'),
      '@redux': path.resolve(__dirname, './src/redux'),
      '@hooks': path.resolve(__dirname, './src/hooks'),
      '@utils': path.resolve(__dirname, './src/utils'),
      '@assets': path.resolve(__dirname, './src/assets'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
      '/ws': {
        target: 'ws://localhost:8000',
        ws: true,
      },
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
});


üîå Core Services Layer
src/services/api.js


import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000';
const API_TIMEOUT = parseInt(import.meta.env.VITE_API_TIMEOUT) || 30000;

// Create axios instance
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: API_TIMEOUT,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor
apiClient.interceptors.request.use(
  (config) => {
    // Add auth token if exists
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    console.log(`[API Request] ${config.method.toUpperCase()} ${config.url}`);
    return config;
  },
  (error) => {
    console.error('[API Request Error]', error);
    return Promise.reject(error);
  }
);

// Response interceptor
apiClient.interceptors.response.use(
  (response) => {
    console.log(`[API Response] ${response.status} ${response.config.url}`);
    return response;
  },
  (error) => {
    if (error.response) {
      console.error(`[API Error] ${error.response.status}:`, error.response.data);
      
      // Handle specific status codes
      if (error.response.status === 401) {
        localStorage.removeItem('authToken');
        window.location.href = '/login';
      }
    } else if (error.request) {
      console.error('[API Error] No response received:', error.request);
    } else {
      console.error('[API Error]', error.message);
    }
    return Promise.reject(error);
  }
);

export default apiClient;



src/services/meetingService.js

import apiClient from './api';

const meetingService = {
  /**
   * Start a new meeting
   * @param {Object} meetingData - { meeting_id, title, language }
   * @returns {Promise}
   */
  startMeeting: async (meetingData) => {
    try {
      const response = await apiClient.post('/api/start_meeting', meetingData);
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.detail || 'Failed to start meeting');
    }
  },

  /**
   * End a meeting
   * @param {string} meetingId
   * @returns {Promise}
   */
  endMeeting: async (meetingId) => {
    try {
      const response = await apiClient.post('/api/end_meeting', { meeting_id: meetingId });
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.detail || 'Failed to end meeting');
    }
  },

  /**
   * Upload audio chunk
   * @param {string} meetingId
   * @param {number} chunkNumber
   * @param {Blob} audioData
   * @param {number} timestamp
   * @param {number} sampleRate
   * @returns {Promise}
   */
  uploadAudioChunk: async (meetingId, chunkNumber, audioData, timestamp, sampleRate = 16000) => {
    try {
      const formData = new FormData();
      formData.append('audio', audioData, `chunk_${chunkNumber}.wav`);

      const response = await apiClient.post('/api/upload_audio', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
          'X-Meeting-ID': meetingId,
          'X-Chunk-Number': chunkNumber,
          'X-Timestamp': timestamp,
          'X-Sample-Rate': sampleRate,
        },
      });
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.detail || 'Failed to upload audio chunk');
    }
  },

  /**
   * Get list of all meetings
   * @returns {Promise<Array>}
   */
  listMeetings: async () => {
    try {
      const response = await apiClient.get('/api/list_meetings');
      return response.data.meetings || [];
    } catch (error) {
      throw new Error(error.response?.data?.detail || 'Failed to fetch meetings');
    }
  },

  /**
   * Get meeting summary
   * @param {string} meetingId
   * @returns {Promise}
   */
  getSummary: async (meetingId) => {
    try {
      const response = await apiClient.get('/api/get_summary', {
        params: { meeting_id: meetingId },
      });
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.detail || 'Failed to fetch summary');
    }
  },

  /**
   * Get meeting transcript
   * @param {string} meetingId
   * @returns {Promise}
   */
  getTranscript: async (meetingId) => {
    try {
      const response = await apiClient.get('/api/get_transcript', {
        params: { meeting_id: meetingId },
      });
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.detail || 'Failed to fetch transcript');
    }
  },

  /**
   * Get meeting agenda
   * @param {string} meetingId
   * @returns {Promise}
   */
  getAgenda: async (meetingId) => {
    try {
      const response = await apiClient.get('/api/get_agenda', {
        params: { meeting_id: meetingId },
      });
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.detail || 'Failed to fetch agenda');
    }
  },
};

export default meetingService;




src/services/qaService.js

import apiClient from './api';

const qaService = {
  /**
   * Ask a question about a meeting
   * @param {string} meetingId
   * @param {string} question
   * @returns {Promise}
   */
  askQuestion: async (meetingId, question) => {
    try {
      const response = await apiClient.post('/api/ask_question', null, {
        params: {
          meeting_id: meetingId,
          question: question,
        },
      });
      return response.data;
    } catch (error) {
      throw new Error(error.response?.data?.detail || 'Failed to get answer');
    }
  },

  /**
   * Get Q&A history for a meeting
   * @param {string} meetingId
   * @returns {Promise<Array>}
   */
  getQAHistory: async (meetingId) => {
    try {
      const response = await apiClient.get('/api/qa_history', {
        params: { meeting_id: meetingId },
      });
      return response.data.history || [];
    } catch (error) {
      throw new Error(error.response?.data?.detail || 'Failed to fetch Q&A history');
    }
  },
};

export default qaService;



src/services/websocketService.js

import { io } from 'socket.io-client';

const WS_BASE_URL = import.meta.env.VITE_WS_BASE_URL || 'ws://localhost:8000';

class WebSocketService {
  constructor() {
    this.socket = null;
    this.listeners = {};
  }

  /**
   * Connect to WebSocket server
   * @param {string} meetingId
   */
  connect(meetingId) {
    if (this.socket && this.socket.connected) {
      console.log('[WebSocket] Already connected');
      return;
    }

    this.socket = io(`${WS_BASE_URL}/ws/meeting/${meetingId}`, {
      transports: ['websocket'],
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
    });

    this.socket.on('connect', () => {
      console.log(`[WebSocket] Connected to meeting ${meetingId}`);
      this.emit('connection_status', { status: 'connected' });
    });

    this.socket.on('disconnect', (reason) => {
      console.log(`[WebSocket] Disconnected: ${reason}`);
      this.emit('connection_status', { status: 'disconnected', reason });
    });

    this.socket.on('chunk_received', (data) => {
      console.log('[WebSocket] Chunk received:', data);
      this.emit('chunk_received', data);
    });

    this.socket.on('transcription_update', (data) => {
      console.log('[WebSocket] Transcription update:', data);
      this.emit('transcription_update', data);
    });

    this.socket.on('meeting_ended', (data) => {
      console.log('[WebSocket] Meeting ended:', data);
      this.emit('meeting_ended', data);
    });

    this.socket.on('error', (error) => {
      console.error('[WebSocket] Error:', error);
      this.emit('error', error);
    });
  }

  /**
   * Disconnect from WebSocket
   */
  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
      console.log('[WebSocket] Disconnected');
    }
  }

  /**
   * Add event listener
   * @param {string} event
   * @param {Function} callback
   */
  on(event, callback) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
  }

  /**
   * Remove event listener
   * @param {string} event
   * @param {Function} callback
   */
  off(event, callback) {
    if (this.listeners[event]) {
      this.listeners[event] = this.listeners[event].filter((cb) => cb !== callback);
    }
  }

  /**
   * Emit event to all listeners
   * @param {string} event
   * @param {*} data
   */
  emit(event, data) {
    if (this.listeners[event]) {
      this.listeners[event].forEach((callback) => callback(data));
    }
  }

  /**
   * Send message to server
   * @param {string} event
   * @param {*} data
   */
  send(event, data) {
    if (this.socket && this.socket.connected) {
      this.socket.emit(event, data);
    }
  }
}

export default new WebSocketService();



üóÉÔ∏è Redux Store Setup
src/redux/store.js

import { configureStore } from '@reduxjs/toolkit';
import meetingReducer from './slices/meetingSlice';
import transcriptReducer from './slices/transcriptSlice';
import qaReducer from './slices/qaSlice';
import uiReducer from './slices/uiSlice';
import websocketMiddleware from './middleware/websocketMiddleware';

const store = configureStore({
  reducer: {
    meetings: meetingReducer,
    transcript: transcriptReducer,
    qa: qaReducer,
    ui: uiReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // Ignore these action types
        ignoredActions: ['meetings/uploadAudioChunk'],
        // Ignore these paths in the state
        ignoredPaths: ['meetings.audioBuffer'],
      },
    }).concat(websocketMiddleware),
});

export default store;





import { configureStore } from '@reduxjs/toolkit';
import meetingReducer from './slices/meetingSlice';
import transcriptReducer from './slices/transcriptSlice';
import qaReducer from './slices/qaSlice';
import uiReducer from './slices/uiSlice';
import websocketMiddleware from './middleware/websocketMiddleware';

const store = configureStore({
  reducer: {
    meetings: meetingReducer,
    transcript: transcriptReducer,
    qa: qaReducer,
    ui: uiReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // Ignore these action types
        ignoredActions: ['meetings/uploadAudioChunk'],
        // Ignore these paths in the state
        ignoredPaths: ['meetings.audioBuffer'],
      },
    }).concat(websocketMiddleware),
});

export default store;



import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import meetingService from '@services/meetingService';

// Async thunks
export const startMeeting = createAsyncThunk(
  'meetings/start',
  async (meetingData, { rejectWithValue }) => {
    try {
      return await meetingService.startMeeting(meetingData);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const endMeeting = createAsyncThunk(
  'meetings/end',
  async (meetingId, { rejectWithValue }) => {
    try {
      return await meetingService.endMeeting(meetingId);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const fetchMeetings = createAsyncThunk(
  'meetings/fetchAll',
  async (_, { rejectWithValue }) => {
    try {
      return await meetingService.listMeetings();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const fetchSummary = createAsyncThunk(
  'meetings/fetchSummary',
  async (meetingId, { rejectWithValue }) => {
    try {
      return await meetingService.getSummary(meetingId);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const uploadAudioChunk = createAsyncThunk(
  'meetings/uploadChunk',
  async ({ meetingId, chunkNumber, audioData, timestamp, sampleRate }, { rejectWithValue }) => {
    try {
      return await meetingService.uploadAudioChunk(meetingId, chunkNumber, audioData, timestamp, sampleRate);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Slice
const meetingSlice = createSlice({
  name: 'meetings',
  initialState: {
    meetings: [],
    currentMeeting: null,
    isRecording: false,
    chunkCount: 0,
    summary: null,
    loading: false,
    error: null,
  },
  reducers: {
    setCurrentMeeting: (state, action) => {
      state.currentMeeting = action.payload;
    },
    setRecordingStatus: (state, action) => {
      state.isRecording = action.payload;
    },
    incrementChunkCount: (state) => {
      state.chunkCount += 1;
    },
    resetChunkCount: (state) => {
      state.chunkCount = 0;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Start Meeting
      .addCase(startMeeting.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(startMeeting.fulfilled, (state, action) => {
        state.loading = false;
        state.currentMeeting = action.payload;
        state.isRecording = true;
        state.chunkCount = 0;
      })
      .addCase(startMeeting.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      // End Meeting
      .addCase(endMeeting.pending, (state) => {
        state.loading = true;
      })
      .addCase(endMeeting.fulfilled, (state, action) => {
        state.loading = false;
        state.isRecording = false;
        if (state.currentMeeting) {
          state.currentMeeting.status = 'completed';
        }
      })
      .addCase(endMeeting.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      // Fetch Meetings
      .addCase(fetchMeetings.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchMeetings.fulfilled, (state, action) => {
        state.loading = false;
        state.meetings = action.payload;
      })
      .addCase(fetchMeetings.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      // Fetch Summary
      .addCase(fetchSummary.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchSummary.fulfilled, (state, action) => {
        state.loading = false;
        state.summary = action.payload;
      })
      .addCase(fetchSummary.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      // Upload Chunk
      .addCase(uploadAudioChunk.fulfilled, (state) => {
        state.chunkCount += 1;
      })
      .addCase(uploadAudioChunk.rejected, (state, action) => {
        state.error = action.payload;
      });
  },
});

export const {
  setCurrentMeeting,
  setRecordingStatus,
  incrementChunkCount,
  resetChunkCount,
  clearError,
} = meetingSlice.actions;

export default meetingSlice.reducer;



src/redux/slices/transcriptSlice.js


import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import meetingService from '@services/meetingService';

export const fetchTranscript = createAsyncThunk(
  'transcript/fetch',
  async (meetingId, { rejectWithValue }) => {
    try {
      return await meetingService.getTranscript(meetingId);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const transcriptSlice = createSlice({
  name: 'transcript',
  initialState: {
    transcript: '',
    segments: [],
    loading: false,
    error: null,
    searchQuery: '',
    filteredSegments: [],
  },
  reducers: {
    setSearchQuery: (state, action) => {
      state.searchQuery = action.payload;
      if (action.payload) {
        state.filteredSegments = state.segments.filter((seg) =>
          seg.text.toLowerCase().includes(action.payload.toLowerCase())
        );
      } else {
        state.filteredSegments = state.segments;
      }
    },
    addTranscriptSegment: (state, action) => {
      state.segments.push(action.payload);
      state.transcript += action.payload.text + ' ';
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTranscript.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchTranscript.fulfilled, (state, action) => {
        state.loading = false;
        state.transcript = action.payload.transcript || '';
        state.segments = action.payload.segments || [];
        state.filteredSegments = state.segments;
      })
      .addCase(fetchTranscript.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export const { setSearchQuery, addTranscriptSegment } = transcriptSlice.actions;
export default transcriptSlice.reducer;



src/redux/slices/transcriptSlice.js


import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import meetingService from '@services/meetingService';

export const fetchTranscript = createAsyncThunk(
  'transcript/fetch',
  async (meetingId, { rejectWithValue }) => {
    try {
      return await meetingService.getTranscript(meetingId);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const transcriptSlice = createSlice({
  name: 'transcript',
  initialState: {
    transcript: '',
    segments: [],
    loading: false,
    error: null,
    searchQuery: '',
    filteredSegments: [],
  },
  reducers: {
    setSearchQuery: (state, action) => {
      state.searchQuery = action.payload;
      if (action.payload) {
        state.filteredSegments = state.segments.filter((seg) =>
          seg.text.toLowerCase().includes(action.payload.toLowerCase())
        );
      } else {
        state.filteredSegments = state.segments;
      }
    },
    addTranscriptSegment: (state, action) => {
      state.segments.push(action.payload);
      state.transcript += action.payload.text + ' ';
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTranscript.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchTranscript.fulfilled, (state, action) => {
        state.loading = false;
        state.transcript = action.payload.transcript || '';
        state.segments = action.payload.segments || [];
        state.filteredSegments = state.segments;
      })
      .addCase(fetchTranscript.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export const { setSearchQuery, addTranscriptSegment } = transcriptSlice.actions;
export default transcriptSlice.reducer;




src/redux/slices/qaSlice.js


import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import qaService from '@services/qaService';

export const askQuestion = createAsyncThunk(
  'qa/ask',
  async ({ meetingId, question }, { rejectWithValue }) => {
    try {
      return await qaService.askQuestion(meetingId, question);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const fetchQAHistory = createAsyncThunk(
  'qa/fetchHistory',
  async (meetingId, { rejectWithValue }) => {
    try {
      return await qaService.getQAHistory(meetingId);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const qaSlice = createSlice({
  name: 'qa',
  initialState: {
    conversations: [],
    loading: false,
    error: null,
  },
  reducers: {
    clearConversations: (state) => {
      state.conversations = [];
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(askQuestion.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(askQuestion.fulfilled, (state, action) => {
        state.loading = false;
        state.conversations.push({
          question: action.meta.arg.question,
          answer: action.payload.answer,
          timestamp: new Date().toISOString(),
        });
      })
      .addCase(askQuestion.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      .addCase(fetchQAHistory.fulfilled, (state, action) => {
        state.conversations = action.payload;
      });
  },
});

export const { clearConversations } = qaSlice.actions;
export default qaSlice.reducer;




Key React Components
src/components/meeting/MeetingList.jsx


import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchMeetings } from '@redux/slices/meetingSlice';
import MeetingCard from './MeetingCard';
import LoadingSpinner from '@components/common/LoadingSpinner';
import { Grid, Typography, Box } from '@mui/material';

const MeetingList = () => {
  const dispatch = useDispatch();
  const { meetings, loading, error } = useSelector((state) => state.meetings);

  useEffect(() => {
    dispatch(fetchMeetings());
  }, [dispatch]);

  if (loading) return <LoadingSpinner />;
  if (error) return <Typography color="error">Error: {error}</Typography>;

  return (
    <Box sx={{ padding: 3 }}>
      <Typography variant="h4" gutterBottom>
        Your Meetings
      </Typography>
      <Grid container spacing={3}>
        {meetings.map((meeting) => (
          <Grid item xs={12} sm={6} md={4} key={meeting.meeting_id}>
            <MeetingCard meeting={meeting} />
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};

export default MeetingList;



src/components/meeting/RecordingControls.jsx


import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { startMeeting, endMeeting } from '@redux/slices/meetingSlice';
import { Button, TextField, Box, CircularProgress } from '@mui/material';
import { Mic, Stop } from '@mui/icons-material';

const RecordingControls = () => {
  const dispatch = useDispatch();
  const { isRecording, currentMeeting, loading } = useSelector((state) => state.meetings);
  const [meetingTitle, setMeetingTitle] = useState('');
  const [language, setLanguage] = useState('en');

  const handleStart = () => {
    const meetingData = {
      meeting_id: `meeting_${Date.now()}`,
      title: meetingTitle || 'Untitled Meeting',
      language: language,
    };
    dispatch(startMeeting(meetingData));
  };

  const handleStop = () => {
    if (currentMeeting) {
      dispatch(endMeeting(currentMeeting.meeting_id));
    }
  };

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, maxWidth: 400 }}>
      <TextField
        label="Meeting Title"
        value={meetingTitle}
        onChange={(e) => setMeetingTitle(e.target.value)}
        disabled={isRecording}
        fullWidth
      />
      <TextField
        label="Language"
        value={language}
        onChange={(e) => setLanguage(e.target.value)}
        disabled={isRecording}
        fullWidth
        helperText="e.g., en, es, zh, hi"
      />
      {!isRecording ? (
        <Button
          variant="contained"
          color="primary"
          startIcon={loading ? <CircularProgress size={20} /> : <Mic />}
          onClick={handleStart}
          disabled={loading}
          fullWidth
        >
          Start Recording
        </Button>
      ) : (
        <Button
          variant="contained"
          color="error"
          startIcon={<Stop />}
          onClick={handleStop}
          disabled={loading}
          fullWidth
        >
          Stop Recording
        </Button>
      )}
    </Box>
  );
};

export default RecordingControls;


src/components/qa/ChatInterface.jsx

import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { askQuestion, fetchQAHistory } from '@redux/slices/qaSlice';
import {
  Box,
  TextField,
  Button,
  Paper,
  Typography,
  List,
  ListItem,
  CircularProgress,
} from '@mui/material';
import { Send } from '@mui/icons-material';

const ChatInterface = ({ meetingId }) => {
  const dispatch = useDispatch();
  const { conversations, loading } = useSelector((state) => state.qa);
  const [question, setQuestion] = useState('');

  useEffect(() => {
    if (meetingId) {
      dispatch(fetchQAHistory(meetingId));
    }
  }, [meetingId, dispatch]);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (question.trim() && meetingId) {
      dispatch(askQuestion({ meetingId, question }));
      setQuestion('');
    }
  };

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      <Paper elevation={2} sx={{ flexGrow: 1, overflow: 'auto', p: 2, mb: 2 }}>
        <List>
          {conversations.map((conv, idx) => (
            <ListItem key={idx} sx={{ flexDirection: 'column', alignItems: 'flex-start' }}>
              <Typography variant="subtitle1" color="primary" sx={{ fontWeight: 'bold' }}>
                Q: {conv.question}
              </Typography>
              <Typography variant="body1" sx={{ mt: 1 }}>
                A: {conv.answer}
              </Typography>
            </ListItem>
          ))}
        </List>
        {loading && <CircularProgress />}
      </Paper>
      <Box component="form" onSubmit={handleSubmit} sx={{ display: 'flex', gap: 1 }}>
        <TextField
          fullWidth
          variant="outlined"
          placeholder="Ask a question about this meeting..."
          value={question}
          onChange={(e) => setQuestion(e.target.value)}
          disabled={loading}
        />
        <Button
          type="submit"
          variant="contained"
          endIcon={<Send />}
          disabled={loading || !question.trim()}
        >
          Ask
        </Button>
      </Box>
    </Box>
  );
};

export default ChatInterface;



üöÄ Complete Setup & Run Guide
Step 1: Install Prerequisites


# Check Node.js version (requires v16+)
node --version
npm --version

# If not installed, download from https://nodejs.org/



Step 2: Clone & Setup Frontend

# Navigate to project root
cd ~/Projects/VoiceMind-Meeting-System

# Create frontend directory and files (use commands from earlier)
# Then install dependencies
cd voicemind-frontend
npm install



Step 3: Configure Environment

# Copy example env file
cp .env.example .env

# Edit .env with your backend URL
nano .env



Update .env:


VITE_API_BASE_URL=http://localhost:8000
VITE_WS_BASE_URL=ws://localhost:8000


Step 4: Start Backend Server

# In a separate terminal, navigate to backend
cd ~/Projects/VoiceMind-Meeting-System/backend

# Activate virtual environment
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Start FastAPI server
python server.py


Backend should now run on http://localhost:8000
Step 5: Start Frontend Dev Server

# In frontend directory
npm run dev


Frontend should now run on http://localhost:3000

Step 6: Test the System
Option A: Manual Browser Testing

Open browser to http://localhost:3000
Enter a meeting title and click "Start Recording"
Upload audio chunks (simulated or from ESP32)
Click "Stop Recording"
View summary, transcript, and ask questions
Option B: API Testing with cURL



# Test health check
curl http://localhost:8000/

# Start a meeting
curl -X POST "http://localhost:8000/api/start_meeting" \
  -H "Content-Type: application/json" \
  -d '{"meeting_id":"test_001","title":"Test Meeting","language":"en"}'

# List meetings
curl http://localhost:8000/api/list_meetings

# Get summary
curl "http://localhost:8000/api/get_summary?meeting_id=test_001"

# Ask question
curl -X POST "http://localhost:8000/api/ask_question?meeting_id=test_001&question=What%20was%20discussed?"




Build for Production


# Build optimized production bundle
npm run build

# Preview production build locally
npm run preview

# Deploy dist/ folder to your hosting (Vercel, Netlify, AWS S3, etc.)




üìä Full System Integration Test
Test Workflow:
Backend Ready: Ensure FastAPI is running on port 8000
Frontend Ready: Start React dev server on port 3000
ESP32 Ready: Flash firmware and configure WiFi
MySQL Ready: Database schema created and accessible
End-to-End Test Script:


#!/bin/bash
# test_system.sh

echo "=== VoiceMind System Integration Test ==="

# 1. Check backend health
echo "1. Checking backend..."
curl -s http://localhost:8000/ || { echo "Backend not running!"; exit 1; }

# 2. Check frontend
echo "2. Checking frontend..."
curl -s http://localhost:3000/ || { echo "Frontend not running!"; exit 1; }

# 3. Start test meeting
echo "3. Starting test meeting..."
MEETING_ID="test_$(date +%s)"
curl -X POST "http://localhost:8000/api/start_meeting" \
  -H "Content-Type: application/json" \
  -d "{\"meeting_id\":\"$MEETING_ID\",\"title\":\"Integration Test\",\"language\":\"en\"}"

# 4. Simulate audio upload (requires test audio file)
echo "4. Uploading test audio chunk..."
# curl -X POST "http://localhost:8000/api/upload_audio" \
#   -H "X-Meeting-ID: $MEETING_ID" \
#   -H "X-Chunk-Number: 1" \
#   -H "X-Timestamp: $(date +%s)000" \
#   -H "X-Sample-Rate: 16000" \
#   -F "audio=@test_audio.wav"

# 5. End meeting
echo "5. Ending meeting..."
curl -X POST "http://localhost:8000/api/end_meeting" \
  -H "Content-Type: application/json" \
  -d "{\"meeting_id\":\"$MEETING_ID\"}"

# 6. Get summary
echo "6. Fetching summary..."
curl "http://localhost:8000/api/get_summary?meeting_id=$MEETING_ID"

echo ""
echo "=== Test Complete ==="




üêõ Troubleshooting
Common Issues:
1. CORS Errors


// Add to backend server.py
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)



2. WebSocket Connection Failed

Check firewall settings
Verify VITE_WS_BASE_URL in .env
Ensure backend WebSocket endpoint is implemented

3. Audio Upload Fails

Verify Content-Type: multipart/form-data
Check audio file format (WAV, 16kHz, 16-bit)
Increase backend timeout for large files

4. Environment Variables Not Loading

Restart Vite dev server after changing .env
Use VITE_ prefix for all variables
Check import.meta.env.VITE_* syntax

VS Code Debugging:


1. Install extensions:

    ESLint
    Prettier
    Debugger for Chrome

2. Create .vscode/launch.json:

{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "chrome",
      "request": "launch",
      "name": "Launch Chrome",
      "url": "http://localhost:3000",
      "webRoot": "${workspaceFolder}/src"
    }
  ]
}


1. Set breakpoints in React components
2. Press F5 to start debugging


üìù Additional Features to Implement

1. User Authentication (JWT tokens)
2. Real-time Waveform Visualization (Wavesurfer.js)
3. Export Transcript (PDF, DOCX, TXT)
4. Speaker Diarization (Color-coded segments)
5. Analytics Dashboard (Meeting duration, word count, sentiment)
6. Dark Mode Toggle
7. Multi-language UI (i18n)
8. Mobile Responsive Design


üéì Summary
This complete MERN frontend provides:

‚úÖ Full Feature Coverage: Recording controls, meeting list, transcript viewer, Q&A chat, summary display
‚úÖ Redux State Management: Centralized state with async thunks
‚úÖ WebSocket Support: Real-time updates during recording
‚úÖ Material-UI Components: Professional, responsive design
‚úÖ API Integration: All FastAPI endpoints mapped
‚úÖ Production Ready: Build scripts, error handling, logging
‚úÖ VS Code Friendly: Complete folder structure with one-command setup



also add more below to this 

(1). Generate additional components (Analytics Dashboard, Settings Page)
(2). Add specific features (export, speaker diarization, dark mode)